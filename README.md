# 마르코프 리워드 프로세스와 확률적 이동 시뮬레이션

## 목차

1. [프로젝트 소개](#프로젝트-소개)
    - [주요 기능](#주요-기능)
2. [프로젝트 구조](#프로젝트-구조)
    - [core 모듈](#core-모듈)
    - [app-cli 모듈](#app-cli-모듈)
    - [app-gui 모듈](#app-gui-모듈)
3. [core 모듈과 출력 모듈 간 연결](#core-모듈과-결과-출력-모듈-간-연결)
    - [출력을 위한 인터페이스](#출력을-위한-인터페이스)
    - [app-cli의 인터페이스 구현](#app-cli에서-인터페이스-구현)
    - [app-gui의 인터페이스 구현](#app-gui에서-인터페이스-구현)
4. [주요 기능(core 모듈)](#주요-기능core-모듈)
    - [지도(`SimulationMap`)](#지도simulationmap)
    - [움직임(`Movement`)](#움직임movement)
    - [시뮬레이션(`Simulation`)](#시뮬레이션simulation)
    - [마르코프 리워드 프로세스와 비용지도(`CostMap`)](#마르코프-리워드-프로세스와-비용-지도costmap)
        - [벨만 방정식](#벨만-방정식-bellman-equation)
        - [핵심 알고리즘: 가치 반복](#핵심-알고리즘-가치-반복findcostmap)
5. [실행 방법](#실행-방법)
    - [테스트 및 실행환경](#테스트-및-실행-환경)
    - [입력 데이터 구성](#입력-데이터-구성)
    - [애플리케이션 실행](#애플리케이션-실행)
6. [구현 할 기능 목록](#구현-할-기능-목록)
7. [부록](#부록)

## 프로젝트 소개

이 프로젝트는 미래의 상태는 오직 현재의 상태에 의해서만 결정되며 과거의 이동 경로는 영향을 주지 않는다는 **마르코프 성질**을 가진 격자 환경을 기반으로 합니다.
이러한 환경에서 **각 위치의 가치를 계산**하고 **확률적인 이동 과정을 시뮬레이션**하는 애플리케이션입니다.

### 주요 기능

- **가치 평가(마르코프 리워드 프로세스)**: 불확실한 이동 확률 속에서 각 위치가 목표 도달에 얼마나 유리한지(가치)를 계산합니다.
- **확률적 이동 시뮬레이션**: 정의된 확률 규칙에 따라 실제로 이동하는 경로를 추적하고 제한 시간 내 목표 도달 여부를 판단합니다.
- **결과 출력**: 텍스트 및 그래픽 인터페이스를 통해 위치별 가치와 이동 과정을 표현합니다.

## 프로젝트 구조

이 프로젝트는 핵심 로직을 담은 `core` 모듈을 중심으로 실행 환경에 따라 `app-cli`와 `app-gui`로 분리된 멀티 모듈 구조로 구성되어 있습니다.

### core 모듈

- **역할**: 마르코프 리워드 프로세스(MRP) 알고리즘, 지도 및 확률 데이터 모델, 핵심 계산 로직을 포함하는 `Kotlin` 모듈입니다. 외부 입출력 장치에 의존하지 않도록 구성했습니다.
- **테스트 환경**: JUnit 5, AssertJ

### app-cli 모듈

- **역할**: 텍스트를 기반으로 시뮬레이션의 진행 상황과 계산된 각 위치의 가치를 로그 형태로 콘솔에 출력하는 `Kotlin` 모듈입니다.
- **의존성**: `core` 모듈의 로직을 사용하여 시뮬레이션을 실행합니다.
- **테스트 환경**: JUnit 5, AssertJ

### app-gui 모듈

- **역할**: Java Swing을 활용하여 위치별 가치를 색상으로 시각화하고 에이전트의 이동 경로를 표현하는 `Java` 모듈입니다.
- **의존성**: `core 모듈의 로직을 사용하여 시뮬레이션을 실행합니다.
- **테스트 환경**: JUnit 4, AssertJ, AssertJ Swing

## core 모듈과 결과 출력 모듈 간 연결

`core` 모듈은 외부 환경(CLI, GUI)에 직접 의존하지 않기 위해 인터페이스(Interface)를 사용합니다.
`app-cli`와 `app-gui` 모듈은 인터페이스를 구현하여 환경에 맞게 출력합니다.

### 출력을 위한 인터페이스

- `MessageOutput`: 시스템 상태 메시지(성공, 에러)를 전달합니다.
- `CostMapOutput`: 계산된 위치별 가치를 전달합니다.
- `SimulationOutput`: 특정 시점의 시뮬레이션을 전달합니다.

### app-cli에서 인터페이스 구현

- **단순 로그 출력**: 3가지 인터페이스 모두에 대해 추가적인 데이터 가공 없이 전달받은 정보를 즉시 콘솔로 출력합니다.

### app-gui에서 인터페이스 구현

- **비용 정규화(`CostMapOutput`)**: 데이터를 받으면 즉시 출력하지 않고 비용 데이터의 최솟값과 최댓값을 산출합니다. 이를 기준으로 각 위치의 비용을 0~1 사이의 값으로 정규화하여 비용이 낮을수록
  초록색, 높을수록 붉은색을 띄도록 표현합니다.
- **임시 저장(`SimulationOutput`)**: `core`의 시뮬레이션 로직은 반복문을 통해 순식간에 모든 단계를 처리하고 결과를 배출합니다. GUI에서는 사용자가 이 과정을 단계별로 확인해야 하므로
  결과를 화면에 바로 그리지 않고 내부 큐(Queue)에 순서대로 저장합니다. 이후 사용자가 버튼을 누를 때마다 큐에서 데이터를 하나씩 꺼내어 화면을 갱신합니다.

## 주요 기능(core 모듈)

### 지도(`SimulationMap`)

시뮬레이션이 수행될 공간을 표현하고 위치 정보들을 저장합니다.

- `SimulationMapController`: `MapReader`를 통해 입력받은 원시 문자열 데이터(`List<String>`)를 분석하여 `SimulationMap` 객체를 생성합니다.
- `SimulationMap`: 지도의 크기(`MapSize`), 출발지(`Position`), 목적지(`Position`), 현재 위치(`Position`)를 불변으로 저장합니다.
    - 선언된 지도 크기(`MapSize`)와 실제 데이터의 일치 여부를 확인합니다.
    - 출발지(`Location`, `s`)와 도착지(`Location`, `d`)가 반드시 하나씩 존재하는지 검증합니다.
    - 잘못된 위치(`Location`)가 있는 지 확인합니다.
- `Position`: `x 좌표`와 `y좌표`를 저장합니다.
    - 이동: `next(ActionType)` 메서드를 통해 특정 방향으로 이동했을 때의 다음 좌표를 계산하여 반환합니다.
- `Location`: 지도 내의 각 칸을 구성하는 요소(`START`, `DESTINATION`, `WAYPOINT`)를 정의한 Enum 클래스입니다.

### 움직임(`Movement`)

각 위치에서 발생할 수 있는 확률적 이동 규칙을 정의합니다.

- `MovementController`: 확률 정보 파일을 읽어 `Movement` 객체를 생성합니다. 이때 지도의 모든 좌표에 대한 확률 정보가 존재하는지 검증합니다.
- `Movement`: 좌표별 `Action` 정보를 저장합니다.
    - 이동 결정: 특정 위치(`Position`)와 수가 주어지면 해당 위치의 `Action`에게 행동 결정을 받아 이동할 다음 좌표를 반환합니다.
- `Action`: 특정 좌표 하나에서의 이동 확률을 관리하는 객체입니다.
    - 확률 검증: 객체 생성 시점에 상, 하, 좌, 우 4방향의 확률 합이 정확히 100인지 검증(require)하여 데이터 무결성을 보장합니다.
    - 행동 결정: 1~100 사이의 수에 해당하는 `ActionType`을 찾습니다.
- `ActionType`: 이동 가능한 방향(`UP`, `RIGHT`, `DOWN`, `LEFT`)을 정의한 Enum 클래스입니다.

### 시뮬레이션(`Simulation`)

정의된 지도와 확률 위에서 이동 과정을 단계별로 실행해 저장합니다.

- `SimulationController`: 시뮬레이션의 진행을 제어합니다. 제한 시간(`SimulationTime`) 동안 루프를 돌며 매 반복의 결과를 `SimulationOutput` 인터페이스로 전달합니다.
- `Simulation`: 특정 시점의 시뮬레이션 상태(지도, 현재 시간, 제한 시간)를 담고 있는 불변객체입니다.
    - 상태 갱신: `next(Position)` 메서드를 호출하면 내부 상태를 변경하는 것이 아니라 이동한 위치와 증가된 시간을 담은 새로운 `Simulation` 객체를 반환합니다.
- `SimulationState`: 현재 시뮬레이션이 어떤 상태인지 판별하는 Enum 클래스입니다.
    - 판별 우선순위: 성공(`SUCCESS`) > 실패(`FAIL`) > 진행 중(`RUNNING`) 순서로 상태를 결정합니다.
    - 종료 조건: 에이전트가 목적지에 도착하면 `SUCCESS`, 제한 시간을 초과하면 `FAIL`로 판정합니다.
- `SimulationTime`: 시간의 흐름을 나타내며 양수임을 보장합니다.

### 마르코프 리워드 프로세스와 비용 지도(`CostMap`)

이 프로젝트의 핵심은 불확실한 확률 환경(마르코프 리워드 프로세스)에서 목적지까지 도달하기 위한 각 위치의 잠재적 비용을 계산하는 것입니다.
이를 위해 벨만 방정식을 정의하고 가치 반복(Value Iteration) 알고리즘을 통해 해를 구합니다.

#### 벨만 방정식 (Bellman Equation)

각 위치의 가치(비용)는 현재 위치의 즉시 비용과 이동 가능한 다음 위치들의 가치 평균의 합으로 정의됩니다.
$$V(s) = R(s) + \gamma \sum_{s'} P(s'|s)V(s')$$

- $V(s)$: 상태 $s$의 가치 (계산 대상)으로 `CostMap`에 해당합니다.
- $R(s)$: 상태 $s$의 즉시 보상/비용으로 `DistanceMap`(목적지까지의 맨해튼 거리)의 특정 위치 값에 해당합니다.
- $P(s'|s)$: 상태 $s$에서 $s'$로 이동할 확률로 `Movement` 객체가 관리하는 위치별 `Action`의 확률에 해당합니다.
    - 미래의 상태는 오직 현재의 상태에 의해서만 결정된다는 마르코프 성질때문에 가능합니다.
- $\gamma$: 감가율(discount factor)로 0에 가까울수록 미래를 무시하고 현재를 중시합니다. `CostMap.DEFAULT_DISCOUNT_FACTOR`는 `0.9`로 설정되어 있습니다.

#### 핵심 알고리즘: 가치 반복(`findCostMap()`)

위 벨만 방정식을 코드로 구현하여 최적의 값을 찾아내는 과정으로 동적계획법을 활용합니다.

가치 반복 과정은 `CostMapController`가 제어합니다.

- 도착지는 `Cost.DESTINATION`, 그 외 위치는 `Cost.INITIAL`로 초기화한 상태에서 시작합니다. 벨만 방정식을 반복적으로 적용해 비용(`Cost`)을 갱신합니다.
- 이전 단계의 지도와 갱신된 지도 간의 비용 차이가 임계값 이하가 될 때까지 반복합니다.
- 부동 소수점 오차 보정: 이론에서는 다루지 않지만 부동소수점 오차로 인한 루프 불변식 통과 실패를 막기 위해 엡실론(Epsilon)을 사용했습니다.

#### 주요 객체

- `CostMapController`: 최적의 비용 지도를 찾기 위해 `가치 반복(Value Iteration) 알고리즘`을 수행합니다.
    - 종료 검사: 이전 단계의 `CostMap`과 현재 단계의 `CostMap` 간의 비용 차이를 계산해 차이가 임계값이하로 줄어들 때까지 반복합니다.
- `CostMap`: 계산된 각 위치의 비용(`Cost`)을 담고 있는 불변 객체입니다.
- `DistanceMap`: 지도의 모든 위치에서 목적지까지의 맨해튼 거리를 계산하여 저장합니다.
    - 두 점 $(x_{1},y_{1})$ 과 $(x_{2},y_{2})$ 사이의 맨해튼 거리는 $|x_{1}-x_{2}|+|y_{1}-y_{2}|$로 계산합니다.
- `Cost`: 비용을 나타내는 값 객체로 초기값과 목적지 값 등을 상수로 관리합니다.


## 실행 방법

### 테스트 및 실행 환경

이 프로젝트는 다음 환경에서 개발되었고 실행을 확인했습니다.

- JDK 21
- Kotlin 2.2.0
- Gradle 8.14.3

### 입력 데이터 구성

입력 데이터는`core/src/main/resources` 경로의 파일을 수정하여 시뮬레이션 환경을 변경할 수 있습니다.
`map.txt`와 `probability.txt`로 두 개의 파일 입력으로 시작됩니다.

#### 지도 설정 (`map.txt`)

첫 줄은 `너비x높이`로 구성되며 아랫줄부터 지도를 그립니다.

- `s`: 출발지 (Start)
- `d`: 목적지 (Destination)
- `.`: 빈 공간

아래는 예시 지도입니다.

```text
3x3
s . .
. . .
. . d
```

#### 확률 설정 (`probability.txt`)

각 좌표별 이동 확률을 x,y:상,우,하,좌 순서로 입력합니다.

- **모든 좌표 정의**: `map.txt`에 정의된 **지도의 크기(모든 좌표)**에 해당하는 확률 정보가 빠짐없이 존재해야 합니다.
- **확률 합계**: 각 위치의 이동 확률은 양수여야 하며 총합은 **반드시 100**이어야 합니다.

```text
0,0:25,25,25,25
...
```


### 애플리케이션 실행

프로젝트에 포함된 gradlew 를 사용하여 간편하게 실행할 수 있습니다.

#### CLI 실행 (`app-cli`)

콘솔 환경에서 텍스트로 시뮬레이션 결과와 계산된 비용을 확인할 수 있습니다.
`--args` 옵션을 통해 시뮬레이션 제한 시간을 설정할 수 있습니다.

```bash
# 사용법: ./gradlew :app-cli:run --args="[시간]"
./gradlew :app-cli:run --args=10
```

#### CLI 실행 (`app-gui`)

Java Swing을 통해 이동과 비용 지도를 시각적으로 확인할 수 있습니다.

```bash
# 사용법: ./gradlew :app-gui:run --args=[시간]
./gradlew :app-gui:run --args=10
```


## 구현 할 기능 목록

### 출발지와 도착지가 안내된 지도를 입력받는 기능

- [x] 지도 파일을 읽어온다
- [x] 지도 크기를 읽어온다
- [x] 지도 크기가 양수가 아니라면 예외를 발생시킨다
- [x] 지도 크기로 입력받은 값이 정수가 아니라면 예외를 발생시킨다
- [x] 지도의 위치 정보(출발지 및 도착지 정보)를 읽어온다
- [x] 실제 지도 데이터가 선언된 크기와 일치하는지 않으면 예외를 발생시킨다
- [x] 지도가 출발지와 도착지를 포함하는지 않는다면 예외를 발생시킨다
- [x] 지도가 출발지와 도착지가 각 두개 이상 포함하면 예외를 발생시킨다
- [x] 지도에 유효하지 않은 값이 포함되었다면 예외를 발생시킨다
- [x] 출발지와 도착지가 안내된 올바른 지도 파일로부터 필요한 데이터를 읽어온다
- [x] 지도를 불러오는데 문제가 없다면 `[SUCCESS]`로 시작하는 성공 메시지를 출력한다
- [x] 지도를 읽어오는 기능에 문제가 있다면 `[ERROR]`로 시작하는 에러 메시지를 출력한다

### 위치 별 확률을 바탕으로 행동 비용 지도를 만드는 기능

- [x] 위치 별 이동확률 정보 파일을 읽어온다
- [x] 위치 별 이동 확률을 저장한다
- [x] 지도 크기와 동일한 위치 개수가 아니라면 예외를 발생시킨다
- [x] 모든 위치에 대한 정보가 존재하는 지 않는다면 예외를 발생시킨다
- [x] 이동 확률이 유효한 범위가 아니라면 예외를 발생시킨다
- [x] 이동 확률의 총합이 유효 범위를 벗어나면 예외를 발생시킨다
- [x] 위치 별 이동 확률을 불러오는데 문제가 없다면 `[SUCCESS]`로 시작하는 성공 메시지를 출력한다
- [x] 위치 별 이동 확률을 읽어오는 기능에 문제가 있다면 `[ERROR]`로 시작하는 에러 메시지를 출력한다
- [x] 도착지까지의 거리(비용)를 계산한다
- [x] 모든 위치에 대해 거리를 계산한다
- [x] 거리를 바탕으로 행동 비용 지도을 만든다
    - [x] 위치 별 확률을 바탕으로 초기 비용 지도를 만든다
    - [x] 이전보다 나아진 비용 지도을 만든다
    - [x] 만들 수 있는 최선의 비용 지도을 만든다
    - [x] 미래의 선택을 덜 중시하는 비용 지도을 만든다
- [x] 계산한 비용 지도를 출력한다
- [x] 위치 별 이동확률 정보 파일을 읽어 비용 지도 결과를 출력한다

### 위치 별 이동 확률을 바탕으로 시뮬레이션하는 기능

- [x] 이동이 불가능한 방향으로의 입력(지도를 벗어나는 입력)은 제자리에 멈춘다
- [x] 시간 제한을 콘솔에서 입력받는다
- [x] 확률에 따라 위치를 이동한다
- [x] 제한 시간을 초과하면 시뮬레이션을 종료한다
- [x] 목적지에 도착하면 시뮬레이션을 종료한다
- [x] 이동할 때마다 결과(이동 및 시간)를 콘솔에 출력한다

### GUI로 결과를 보여주는 기능

- [x] 윈도우 타이틀을 요구사항에 맞게 출력한다
- [x] 지도를 불러오면 메시지를 출력한다
- [x] 위치 별 이동확률을 불려오면 메시지를 출력한다
- [x] 현재 위치와 도착 위치가 포함된 지도를 화면에 출력한다
- [x] 위치 별 이동 확률을 각 위치에 출력한다
- [x] 비용 지도를 통해 각 위치별 가치를 표시한다
- [x] 지도를 바탕으로 초기 위치를 출력한다
- [x] 다음 버튼 클릭 시 이동된 방향을 출력한다
- [x] 현재 몇 번째 시뮬레이션인지 화면에 출력한다
- [x] 게임이 종료되면 메시지를 출력한다 

## 부록
